# CYCLE 变量算法详解

本文档详细说明 CYCLE 类型变量的阶段计算算法，包括返回值的生成规则和索引顺序。

---

## 核心概念

### CYCLE 变量的作用

CYCLE 变量用于处理**周期性嵌套**的数值系统，例如：

* **时间系统** ：秒 → 分 → 时 → 日 → 月 → 年
* **层级系统** ：经验值 → 等级 → 段位 → 赛季

---

## 算法原理

### 输入参数

1. **raw_value** （`r`）：原始数值（如总分钟数、总经验值）
2. **relative_stage_config** （`[n0, n1, n2, ..., nN-1]`）：周期配置数组

### 计算过程

算法将原始值 `r` 分解为多级余数，模拟"进位"过程。

#### 步骤 1：初始化数组

```python
N = len(relative_stage_config)  # 配置数组长度
x = [0] * N                     # 商数组
y = [0] * (N - 1)               # 余数数组（重要：长度为 N-1）
```

#### 步骤 2：计算第一级

```python
x[0] = int(r // n0)  # r 除以第一级周期，取整
```

 **含义** ：将原始值转换为第一级的"单位数"

#### 步骤 3：递归计算后续级别

```python
for i in range(1, N):
    x[i] = int(x[i-1] // relative_stage_config[i])  # 上一级的商 ÷ 当前级周期
    y[i-1] = int(x[i-1] % relative_stage_config[i]) # 上一级的商 % 当前级周期
```

 **关键点** ：

* `x[i]`：当前级别的"进位商"
* `y[i-1]`：上一级别的"余数"（即当前级别的索引值）

#### 步骤 4：生成返回值

```python
# 情况 1：N = 2（只有两级）
if N == 2:
    relative_value = y[0]  # 返回单个整数

# 情况 2：N > 2（多级）
else:
    relative_value = tuple(reversed(y))  # 倒序返回元组
```

 **重要规则** ：

* **返回长度** ：总是 `N - 1`（不包含最小一级的余数）
* **返回顺序** ： **倒序** （从大单位到小单位）

---

## 实例详解

### 示例 1：时间系统（分钟 → 小时 → 天）

#### 配置

```python
relative_stage_config = [60, 24]  # 60分钟/小时，24小时/天
raw_value = 1500  # 1500 分钟
```

#### 计算过程

 **步骤 1** ：初始化

```python
N = 2
x = [0, 0]
y = [0]
```

 **步骤 2** ：计算第一级

```python
x[0] = 1500 // 60 = 25  # 1500 分钟 = 25 小时
```

 **步骤 3** ：计算第二级

```python
i = 1:
    x[1] = 25 // 24 = 1       # 25 小时 = 1 天（进位）
    y[0] = 25 % 24 = 1        # 余 1 小时
```

 **步骤 4** ：生成返回值

```python
N = 2，返回单个整数：
relative_value = y[0] = 1  # 第 1 小时（索引从 0 开始）
```

#### 结果

| 原始值    | 换算     | relative_value | 含义                     |
| --------- | -------- | -------------- | ------------------------ |
| 1500 分钟 | 1天1小时 | 1              | 第 1 小时（0-23 范围内） |

---

### 示例 2：完整时间系统（分钟 → 小时 → 天 → 月）

#### 配置

```python
relative_stage_config = [60, 24, 30]  # 60分/时，24时/天，30天/月
raw_value = 45000  # 45000 分钟
```

#### 计算过程

 **步骤 1** ：初始化

```python
N = 3
x = [0, 0, 0]
y = [0, 0]
```

 **步骤 2** ：计算第一级

```python
x[0] = 45000 // 60 = 750  # 750 小时
```

 **步骤 3** ：计算后续级别

```python
i = 1:
    x[1] = 750 // 24 = 31     # 31 天
    y[0] = 750 % 24 = 6       # 余 6 小时

i = 2:
    x[2] = 31 // 30 = 1       # 1 月（进位）
    y[1] = 31 % 30 = 1        # 余 1 天
```

 **步骤 4** ：生成返回值

```python
N > 2，返回倒序元组：
y = [6, 1]  # [小时索引, 天数索引]
relative_value = tuple(reversed(y)) = (1, 6)  # (天数索引, 小时索引)
```

#### 结果

| 原始值     | 换算        | relative_value | 含义                               |
| ---------- | ----------- | -------------- | ---------------------------------- |
| 45000 分钟 | 1月1天6小时 | (1, 6)         | 第 1 天（0-29），第 6 小时（0-23） |

 **注意** ：返回值 **不包含月份信息** （最高级的进位被舍弃）！

---

### 示例 3：复杂时间系统（分钟 → 时段 → 天 → 旬 → 月）

#### 配置

```python
relative_stage_config = [360, 4, 10, 3, 12]
# 360分钟/时段（6小时）
# 4时段/天
# 10天/旬
# 3旬/月
# 12月/年
raw_value = 7320  # 7320 分钟
```

#### 计算过程

 **步骤 1-2** ：初始化与第一级

```python
N = 5
x[0] = 7320 // 360 = 20.33... → 20  # 20 个时段
```

 **步骤 3** ：递归计算

```python
i = 1: (时段 → 天)
    x[1] = 20 // 4 = 5        # 5 天
    y[0] = 20 % 4 = 0         # 余 0 时段（第 0 时段 = 凌晨）

i = 2: (天 → 旬)
    x[2] = 5 // 10 = 0        # 0 旬（未满一旬）
    y[1] = 5 % 10 = 5         # 余 5 天

i = 3: (旬 → 月)
    x[3] = 0 // 3 = 0         # 0 月
    y[2] = 0 % 3 = 0          # 余 0 旬（第 0 旬 = 上旬）

i = 4: (月 → 年)
    x[4] = 0 // 12 = 0        # 0 年
    y[3] = 0 % 12 = 0         # 余 0 月（第 0 月 = 一月）
```

 **步骤 4** ：生成返回值

```python
y = [0, 5, 0, 0]  # [时段, 天, 旬, 月]
relative_value = tuple(reversed(y)) = (0, 0, 5, 0)  # (月, 旬, 天, 时段)
```

#### 结果

| 原始值    | 换算  | relative_value | 含义              |
| --------- | ----- | -------------- | ----------------- |
| 7320 分钟 | 5天零 | (0, 0, 5, 0)   | 一月上旬第5天凌晨 |

 **总索引映射** （用于 `variable_binding_method`）：

* 总索引 0 → 月份（0 = 一月）
* 总索引 1 → 旬（0 = 上旬）
* 总索引 2 → 天数（5 = 第5天）
* 总索引 3 → 时段（0 = 凌晨）

---

## 重要特性总结

### 1. 返回值长度规则

```
返回值长度 = N - 1
```

 **原因** ：最小一级（`n0`）只用于计算第一个商 `x[0]`，其余数 **不保留** 。

 **示例** ：

* `[60, 24]`（2 级）→ 返回 1 个值
* `[60, 24, 30]`（3 级）→ 返回 2 个值
* `[360, 4, 10, 3, 12]`（5 级）→ 返回 4 个值

### 2. 返回值顺序规则

```
返回顺序 = 倒序（从大单位到小单位）
```

 **计算顺序** ：小 → 大（y[0], y[1], y[2], ...）
 **返回顺序** ：大 → 小（..., y[2], y[1], y[0]）

 **示例** ：

```python
y = [时段, 天, 旬, 月]  # 计算顺序
relative_value = (月, 旬, 天, 时段)  # 返回顺序（reversed）
```

### 3. 最高级进位舍弃

CYCLE 算法 **只保留余数** ，最高级的进位（`x[N-1]`） **不在返回值中** 。

 **示例** ：

```python
relative_stage_config = [30, 12]  # 30天/月，12月/年
raw_value = 400  # 400 天

计算：
x[0] = 400 // 30 = 13  # 13 个月
x[1] = 13 // 12 = 1    # 1 年（进位，舍弃）
y[0] = 13 % 12 = 1     # 余 1 月（保留）

返回：
relative_value = 1  # 只返回"第 1 月"，不含"第 1 年"
```

 **应用场景** ：月份循环（1-12 月周而复始）

---

## 在 Prompts Config 中的应用

### 场景 1：使用 CYCLE 变量的部分索引

 **变量定义** （variables_config.json）：

```json
{
  "name": "日期",
  "var_type": "stage_independent",
  "relative_method": "cycle",
  "relative_stage_config": [360, 4, 10, 3, 12],
  "relative_description": [
    ["一月", "二月", ..., "十二月"],
    ["上旬", "中旬", "下旬"],
    ["1日", "2日", ..., "10日"],
    ["凌晨", "上午", "下午", "晚上"]
  ]
}
```

 **Prompts 配置** （prompts_config.json）：

```json
{
  "variable_binding": "日期",
  "variable_binding_method": [0, 2, 3]
}
```

 **解释** ：

* 总索引 0 = 月份
* 总索引 1 = 旬（ **跳过** ）
* 总索引 2 = 天数
* 总索引 3 = 时段

**为什么可以跳过索引 1？**

* 配置中不需要显示"旬"信息
* 但必须在 `relative_description` 中定义"旬"的描述（用于占位符 `{element_1}`）

---

### 场景 2：占位符替换（）

 **⚠️ 重要** ：占位符 `{element_n}` 中的 `n` 也使用 **总索引** ！

#### 示例配置

```json
"variable_binding": ["好感度", "日期", "饥饿度"]
```

假设返回值和描述：

* 好感度（LADDER）：`"熟悉"` → 总索引 **0**
* 日期（CYCLE）：`("三月", "15日", "中旬", "下午")` → 总索引 **1, 2, 3, 4**
* 饥饿度（LADDER）：`"饥饿"` → 总索引 **5**

#### 总索引映射表

| 总索引 | 变量    | 描述   |
| ------ | ------- | ------ |
| 0      | 好感度  | "熟悉" |
| 1      | 日期[0] | "三月" |
| 2      | 日期[1] | "15日" |
| 3      | 日期[2] | "中旬" |
| 4      | 日期[3] | "下午" |
| 5      | 饥饿度  | "饥饿" |

#### 文件内容示例

 **base_file.txt** ：

```
当前时间为{element_1}{element_2}{element_4}，关系状态为{element_0}，饥饿程度为{element_5}。
```

 **渲染后** ：

```
当前时间为三月15日下午，关系状态为熟悉，饥饿程度为饥饿。
```

#### ⚠️ 常见错误

❌  **错误写法** ：

```
当前时间为{element_1}，关系为{element_0}，饥饿度为{element_2}
```

 **问题** ：

* `{element_1}` 只是"三月"（日期的第一个索引）
* `{element_2}` 是"15日"（日期的第二个索引），不是饥饿度！
* 饥饿度应该是 `{element_5}`

✓  **正确写法** ：

```
当前时间为{element_1}{element_2}{element_4}，关系为{element_0}，饥饿度为{element_5}
```

或者只用月份和时段：

```
{element_1}{element_4}，关系为{element_0}，饥饿度为{element_5}
```

---

### 场景 3：制作索引映射表（强烈推荐）

在编写复杂配置时，先制作总索引映射表可以避免 99% 的错误！

#### 步骤 1：确定变量和返回值

```json
"variable_binding": ["好感度", "日期", "体力"]
```

查看每个变量的配置：

* 好感度（LADDER）→ 1 个值
* 日期（CYCLE，N=5）→ 4 个值（N-1）
* 体力（LADDER）→ 1 个值

 **总共** ：1 + 4 + 1 =  **6 个总索引** （0-5）

#### 步骤 2：列出映射表

| 总索引 | 变量    | 说明       | 占位符          | variable_binding_method |
| ------ | ------- | ---------- | --------------- | ----------------------- |
| 0      | 好感度  | 好感度阶段 | `{element_0}` | `0`                   |
| 1      | 日期[0] | 月份       | `{element_1}` | `1`                   |
| 2      | 日期[1] | 日期       | `{element_2}` | `2`                   |
| 3      | 日期[2] | 旬         | `{element_3}` | `3`                   |
| 4      | 日期[3] | 时段       | `{element_4}` | `4`                   |
| 5      | 体力    | 体力阶段   | `{element_5}` | `5`                   |

#### 步骤 3：配置 stages

```json
"variable_binding_method": [[0, 1], 5]
```

* `part_0` 使用总索引 0 和 1（好感度 + 月份）
* `part_1` 使用总索引 5（体力）

```json
"stages": {
  "part_0": {
    "stage_0_0": "...",  // 好感度=0, 月份=0（一月）
    "stage_0_1": "...",  // 好感度=0, 月份=1（二月）
    "stage_1_0": "...",  // 好感度=1, 月份=0（一月）
    // ...
  },
  "part_1": {
    "stage_0": "...",    // 体力=0
    "stage_1": "...",    // 体力=1
    // ...
  }
}
```

#### 步骤 4：编写文件内容

 **base_file.txt** ：

```
时间：{element_1}{element_2}{element_4}
状态：关系{element_0}，体力{element_5}
```

有了映射表，就不会搞错占位符了！

---

## 常见问题

### Q1: 为什么返回值不包含最小一级？

 **A** : 最小一级（如"分钟"）通常只是计量单位，实际系统关心的是更高级别的索引（如"小时"）。

 **类比** ：就像日常说"现在是下午 3 点"，不会精确到"15:27:38.123"。

### Q2: 如果我需要最小一级的信息怎么办？

 **A** : 调整配置，让你需要的级别不是最小级。

 **示例** ：

```python
# 想要保留"分钟"信息
原配置: [60, 24]  # 分钟 → 小时
调整后: [1, 60, 24]  # 秒 → 分钟 → 小时

这样返回值会包含"分钟"索引
```

### Q3: 为什么返回值是倒序的？

 **A** : 符合人类习惯（先说大单位，后说小单位）。

 **示例** ：

* 人类习惯："2025年3月15日下午3点"
* 计算顺序：分钟 → 小时 → 日 → 月 → 年
* 返回顺序：年 → 月 → 日 → 小时 → 分钟（倒序）

### Q4: 总索引如何计算？

 **A** : 按 `variable_binding` 顺序，展开每个变量的 `relative_value`，累加长度。

 **示例** ：

```json
"variable_binding": ["好感度", "日期", "饥饿度"]
```

* 好感度（LADDER）：1 个值 → 总索引 [0]
* 日期（CYCLE，N=5）：4 个值 → 总索引 [1, 2, 3, 4]
* 饥饿度（LADDER）：1 个值 → 总索引 [5]

---

## 相关文档

* **变量配置指南** ：variables_config_guide.md
* **Prompts 配置指南** ：prompts_config_guide.md
